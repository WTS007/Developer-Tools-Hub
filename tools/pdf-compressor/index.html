<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Image Compressor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js for reading/rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <!-- pdf-lib.js for creating/writing PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border: 4px solid #4A5568; /* dark-gray-600 */
            border-top: 4px solid #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom slider styles for dark theme */
        input[type=range]::-webkit-slider-runnable-track {
            background: #374151; /* dark-gray-700 */
        }
        input[type=range]::-moz-range-track {
            background: #374151; /* dark-gray-700 */
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #3b82f6; /* blue-500 */
            height: 16px;
            width: 16px;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px; /* align thumb with track */
        }
        input[type=range]::-moz-range-thumb {
            background: #3b82f6; /* blue-500 */
            height: 16px;
            width: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body class="bg-slate-900 text-gray-300">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white">PDF Image Compressor</h1>
            <p class="text-md text-gray-400 mt-2">Reduces the file size of PDFs by re-compressing the images inside them.</p>
        </header>

        <main>
            <!-- Controls Section -->
            <div class="bg-slate-800 rounded-lg shadow-2xl p-6 mb-8 border border-slate-700">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-end">
                    <div class="flex flex-col">
                        <label for="pdf-upload" class="mb-2 font-semibold text-gray-300">1. Upload PDF</label>
                        <input type="file" id="pdf-upload" accept="application/pdf" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-blue-300 hover:file:bg-slate-600 cursor-pointer">
                    </div>
                    <div class="flex flex-col">
                        <label for="slider" class="mb-2 font-semibold text-gray-300">2. Set Image Quality (<span id="slider-value">75</span>)</label>
                        <input type="range" id="slider" min="1" max="100" value="75" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="w-full">
                        <button id="compress-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors disabled:bg-slate-600 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>
                            Compress PDF
                        </button>
                    </div>
                </div>
                <p id="error-message" class="text-red-400 text-center mt-4 hidden"></p>
            </div>

            <!-- Status/Results Section -->
            <div id="status-container" class="hidden bg-slate-800 rounded-lg shadow-2xl p-6 text-center border border-slate-700">
                <div id="loader-section" class="hidden">
                    <div class="loader inline-block"></div>
                    <p id="status-text" class="text-gray-400 mt-2 font-semibold">Processing...</p>
                </div>
                <div id="summary-section" class="hidden">
                    <h2 class="text-xl font-bold mb-4 text-white">Compression Complete!</h2>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 divide-y md:divide-y-0 md:divide-x divide-slate-700 py-4">
                        <div class="pt-2 md:pt-0">
                            <p class="text-gray-400">Original Size</p>
                            <p id="original-size" class="font-bold text-lg text-gray-200"></p>
                        </div>
                        <div class="pt-2 md:pt-0">
                            <p class="text-gray-400">New Size</p>
                            <p id="compressed-size" class="font-bold text-lg text-blue-400"></p>
                        </div>
                        <div class="pt-2 md:pt-0">
                            <p class="text-gray-400">Reduction</p>
                            <p id="reduction-percent" class="font-bold text-lg text-green-400"></p>
                        </div>
                    </div>
                    <a id="download-btn" href="#" download="compressed.pdf" class="mt-6 inline-block bg-green-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-green-700 transition-colors">Download PDF</a>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Set worker source for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;

        // DOM Elements
        const pdfUpload = document.getElementById('pdf-upload');
        const slider = document.getElementById('slider');
        const sliderValue = document.getElementById('slider-value');
        const compressBtn = document.getElementById('compress-btn');
        const statusContainer = document.getElementById('status-container');
        const loaderSection = document.getElementById('loader-section');
        const summarySection = document.getElementById('summary-section');
        const statusText = document.getElementById('status-text');
        const errorMessage = document.getElementById('error-message');
        const originalSizeText = document.getElementById('original-size');
        const compressedSizeText = document.getElementById('compressed-size');
        const reductionPercentText = document.getElementById('reduction-percent');
        const downloadBtn = document.getElementById('download-btn');

        let originalPdfFile = null;
        let currentObjectUrl = null;

        // --- EVENT LISTENERS ---
        slider.addEventListener('input', () => { sliderValue.textContent = slider.value; });
        pdfUpload.addEventListener('change', handlePdfUpload);
        compressBtn.addEventListener('click', handleCompression);

        function showError(msg) {
            errorMessage.textContent = msg;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }
        
        function updateStatus(text) {
            statusText.textContent = text;
        }

        function handlePdfUpload(e) {
            hideError();
            statusContainer.classList.add('hidden');
            const file = e.target.files[0];
            if (!file) {
                compressBtn.disabled = true;
                originalPdfFile = null;
                return;
            }

            if (file.type !== 'application/pdf') {
                showError('Invalid file type. Please upload a PDF.');
                pdfUpload.value = '';
                compressBtn.disabled = true;
                originalPdfFile = null;
                return;
            }

            originalPdfFile = file;
            compressBtn.disabled = false;
        }

        async function handleCompression() {
            if (!originalPdfFile) {
                showError('Please upload a PDF file first.');
                return;
            }
            hideError();
            
            // Show loader and reset UI
            statusContainer.classList.remove('hidden');
            loaderSection.classList.remove('hidden');
            summarySection.classList.add('hidden');
            compressBtn.disabled = true;
            if(currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);


            try {
                const quality = parseInt(slider.value, 10);
                const fileReader = new FileReader();

                fileReader.onload = async (e) => {
                    const pdfData = new Uint8Array(e.target.result);
                    
                    updateStatus('Loading PDF...');
                    const pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                    const numPages = pdfDoc.numPages;

                    const { PDFDocument } = PDFLib;
                    const newPdfDoc = await PDFDocument.create();

                    for (let i = 1; i <= numPages; i++) {
                        updateStatus(`Processing page ${i} of ${numPages}...`);
                        const page = await pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1.5 }); // Use a good scale for quality

                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Use our existing JPEG logic to compress the page image
                        const compressedImageData = jpegCompress(imageData, quality);
                        
                        // Put compressed data back on a canvas to get a data URL
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = compressedImageData.width;
                        tempCanvas.height = compressedImageData.height;
                        tempCanvas.getContext('2d').putImageData(compressedImageData, 0, 0);

                        const jpegImageBytes = await fetch(tempCanvas.toDataURL('image/jpeg', quality / 100)).then(res => res.arrayBuffer());
                        const jpegImage = await newPdfDoc.embedJpg(jpegImageBytes);

                        const newPage = newPdfDoc.addPage([viewport.width, viewport.height]);
                        newPage.drawImage(jpegImage, {
                            x: 0,
                            y: 0,
                            width: newPage.getWidth(),
                            height: newPage.getHeight(),
                        });
                    }

                    updateStatus('Finalizing PDF...');
                    const newPdfBytes = await newPdfDoc.save();
                    const pdfBlob = new Blob([newPdfBytes], { type: 'application/pdf' });
                    
                    displayResults(originalPdfFile.size, pdfBlob);
                };

                fileReader.readAsArrayBuffer(originalPdfFile);

            } catch (error) {
                console.error("Compression failed:", error);
                showError(`An error occurred: ${error.message}`);
                loaderSection.classList.add('hidden');
            } finally {
                compressBtn.disabled = false;
            }
        }
        
        function displayResults(originalSize, compressedBlob) {
             loaderSection.classList.add('hidden');
             summarySection.classList.remove('hidden');
             
             const compressedSize = compressedBlob.size;
             const reduction = 100 - (compressedSize / originalSize) * 100;

             originalSizeText.textContent = formatFileSize(originalSize);
             compressedSizeText.textContent = formatFileSize(compressedSize);
             reductionPercentText.textContent = `${reduction > 0 ? reduction.toFixed(2) : 0}%`;
             
             currentObjectUrl = URL.createObjectURL(compressedBlob);
             downloadBtn.href = currentObjectUrl;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
        }
        
        const LUMINANCE_QUANTIZATION_TABLE = [16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99];
        const CHROMINANCE_QUANTIZATION_TABLE = [17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99];
        const DCT_BASIS = new Array(8).fill(0).map(()=>new Array(8).fill(0));
        for(let i=0;i<8;i++){for(let j=0;j<8;j++){DCT_BASIS[i][j]=Math.cos((2*i+1)*j*Math.PI/16);}}
        function jpegCompress(imageData, quality) {const width = imageData.width, height = imageData.height;const paddedWidth = Math.ceil(width/8)*8, paddedHeight = Math.ceil(height/8)*8;const paddedData = padImage(imageData, paddedWidth, paddedHeight);const {y,cb,cr} = rgbToYcbcr(paddedData.data,paddedWidth,paddedHeight);const finalRgb = new Uint8ClampedArray(paddedWidth*paddedHeight*4);for(let i=0;i<paddedHeight;i+=8){for(let j=0;j<paddedWidth;j+=8){const yBlock=getBlock(y,j,i,paddedWidth),cbBlock=getBlock(cb,j,i,paddedWidth),crBlock=getBlock(cr,j,i,paddedWidth);const centeredY=centerBlock(yBlock),centeredCb=centerBlock(cbBlock),centeredCr=centerBlock(crBlock);const dctY=forwardDCT(centeredY),dctCb=forwardDCT(centeredCb),dctCr=forwardDCT(centeredCr);const quantY=quantize(dctY,LUMINANCE_QUANTIZATION_TABLE,quality),quantCb=quantize(dctCb,CHROMINANCE_QUANTIZATION_TABLE,quality),quantCr=quantize(dctCr,CHROMINANCE_QUANTIZATION_TABLE,quality);const dequantY=dequantize(quantY,LUMINANCE_QUANTIZATION_TABLE,quality),dequantCb=dequantize(quantCb,CHROMINANCE_QUANTIZATION_TABLE,quality),dequantCr=dequantize(quantCr,CHROMINANCE_QUANTIZATION_TABLE,quality);const idctY=inverseDCT(dequantY),idctCb=inverseDCT(dequantCb),idctCr=inverseDCT(dequantCr);const finalY=uncenterBlock(idctY),finalCb=uncenterBlock(idctCb),finalCr=uncenterBlock(idctCr);placeBlock(finalRgb,finalY,finalCb,finalCr,j,i,paddedWidth);}}const finalImageData=new ImageData(finalRgb,paddedWidth,paddedHeight);return cropImage(finalImageData,width,height);}
        function padImage(imageData,newWidth,newHeight){const oldWidth=imageData.width,oldHeight=imageData.height,oldData=imageData.data,newData=new Uint8ClampedArray(newWidth*newHeight*4);for(let y=0;y<newHeight;y++){for(let x=0;x<newWidth;x++){const oldX=Math.min(x,oldWidth-1),oldY=Math.min(y,oldHeight-1),oldIndex=(oldY*oldWidth+oldX)*4,newIndex=(y*newWidth+x)*4;newData[newIndex]=oldData[oldIndex];newData[newIndex+1]=oldData[oldIndex+1];newData[newIndex+2]=oldData[oldIndex+2];newData[newIndex+3]=oldData[oldIndex+3];}}return{data:newData,width:newWidth,height:newHeight};}
        function cropImage(imageData,newWidth,newHeight){const oldWidth=imageData.width,oldData=imageData.data,newData=new Uint8ClampedArray(newWidth*newHeight*4);for(let y=0;y<newHeight;y++){const oldRowStart=y*oldWidth*4,newRowStart=y*newWidth*4;newData.set(oldData.subarray(oldRowStart,oldRowStart+newWidth*4),newRowStart);}return new ImageData(newData,newWidth,newHeight);}
        function rgbToYcbcr(data,width,height){const y=new Float32Array(width*height),cb=new Float32Array(width*height),cr=new Float32Array(width*height);for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2],index=i/4;y[index]=.299*r+.587*g+.114*b;cb[index]=128-.168736*r-.331264*g+.5*b;cr[index]=128+.5*r-.418688*g-.081312*b;}return{y,cb,cr};}
        function getBlock(channelData,startX,startY,width){const block=new Float32Array(64);for(let y=0;y<8;y++){for(let x=0;x<8;x++){block[y*8+x]=channelData[(startY+y)*width+(startX+x)];}}return block;}
        function centerBlock(block){const newBlock=new Float32Array(64);for(let i=0;i<64;i++){newBlock[i]=block[i]-128;}return newBlock;}
        function uncenterBlock(block){const newBlock=new Float32Array(64);for(let i=0;i<64;i++){newBlock[i]=block[i]+128;}return newBlock;}
        function forwardDCT(block){const dctCoeffs=new Float32Array(64);for(let v=0;v<8;v++){for(let u=0;u<8;u++){let sum=0;for(let y=0;y<8;y++){for(let x=0;x<8;x++){sum+=block[y*8+x]*DCT_BASIS[x][u]*DCT_BASIS[y][v];}}const cu=u===0?1/Math.sqrt(2):1,cv=v===0?1/Math.sqrt(2):1;dctCoeffs[v*8+u]=.25*cu*cv*sum;}}return dctCoeffs;}
        function quantize(dctBlock,qTable,quality){const scale=quality<50?5000/quality:200-2*quality,qBlock=new Float32Array(64);for(let i=0;i<64;i++){const qValue=(qTable[i]*scale+50)/100;qBlock[i]=Math.round(dctBlock[i]/qValue);}return qBlock;}
        function dequantize(qBlock,qTable,quality){const scale=quality<50?5000/quality:200-2*quality,dctBlock=new Float32Array(64);for(let i=0;i<64;i++){const qValue=(qTable[i]*scale+50)/100;dctBlock[i]=qBlock[i]*qValue;}return dctBlock;}
        function inverseDCT(dctCoeffs){const block=new Float32Array(64);for(let y=0;y<8;y++){for(let x=0;x<8;x++){let sum=0;for(let v=0;v<8;v++){for(let u=0;u<8;u++){const cu=u===0?1/Math.sqrt(2):1,cv=v===0?1/Math.sqrt(2):1;sum+=cu*cv*dctCoeffs[v*8+u]*DCT_BASIS[x][u]*DCT_BASIS[y][v];}}block[y*8+x]=.25*sum;}}return block;}
        function placeBlock(finalRgb,yBlock,cbBlock,crBlock,startX,startY,width){for(let y=0;y<8;y++){for(let x=0;x<8;x++){const blockIndex=y*8+x,Y=yBlock[blockIndex],Cb=cbBlock[blockIndex],Cr=crBlock[blockIndex],r=Y+1.402*(Cr-128),g=Y-.344136*(Cb-128)-.714136*(Cr-128),b=Y+1.772*(Cb-128),finalIndex=((startY+y)*width+(startX+x))*4;finalRgb[finalIndex]=r;finalRgb[finalIndex+1]=g;finalRgb[finalIndex+2]=b;finalRgb[finalIndex+3]=255;}}}

    </script>
</body>
</html>